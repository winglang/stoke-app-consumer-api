'use strict';

// tests for users.js functions
// Generated by serverless-jest-plugin

const mod = require('../src/users');
const jestPlugin = require('serverless-jest-plugin');
const { UsersService, CompaniesService, constants } = require('stoke-app-common-api');
const usersService = new UsersService(process.env.consumerAuthTableName, constants.projectionExpression.defaultAttributes, constants.attributeNames.defaultAttributes);
const companiesService = new CompaniesService(process.env.customersTableName, constants.projectionExpression.defaultAttributes, constants.attributeNames.defaultAttributes);
const lambdaWrapper = jestPlugin.lambdaWrapper;
const wrapperGetUsers = lambdaWrapper.wrap(mod, { handler: 'getUsersInEntity' });

const userId = "JEST-TEST-GET-USERS-COMPANY-ADMIN"
const userId2 = "JEST-TEST-GET-USERS-COMPANY-ADMIN2"
const userIdAdminEntity = "JEST-TEST-GET-USERS_ENTITY_ADMIN"
const entityId = "JEST-TEST-GET-USERS-ENTITY"
const userName = "JEST-TEST-GET-USERS@stokeco.com"
const userName2 = "JEST-TEST-GET-USERS2@stokeco.com"
const userEmail = "joe@stokeco.com"
const givenName = "joe"
const familyName = "Shmoe"
const entityName = "stoke"
const companyId = "JEST-TEST-GET-USERS-COMPANY"
const userItem = {
    userId: userId,
    companyId: companyId,
    entityId: entityId,
    createdBy: userId,
    modifiedBy: userId,
    entityName: entityName,
    itemStatus: constants.user.status.active,
    itemData: {
        userRole: constants.user.role.user
    }
};

const userItemAdminCompany = {
    userId: userId,
    companyId: companyId,
    entityId: companyId,
    createdBy: userId,
    modifiedBy: userId,
    entityName: entityName,
    itemStatus: constants.user.status.active,
    itemData: {
        userRole: constants.user.role.admin
    }
};

const userItemAdminCompany2 = {
    userId: userId2,
    companyId: companyId,
    entityId: companyId,
    createdBy: userId,
    modifiedBy: userId,
    entityName: entityName,
    itemStatus: constants.user.status.active,
    itemData: {
        userRole: constants.user.role.admin
    }
};

const userItemAdminEntity = {
    userId: userIdAdminEntity,
    companyId: companyId,
    entityId: entityId,
    createdBy: userId,
    modifiedBy: userId,
    entityName: entityName,
    itemStatus: constants.user.status.active,
    itemData: {
        userRole: constants.user.role.admin
    }
};

const userItemNotAdminCompany = {
    userId: userIdAdminEntity,
    companyId: companyId,
    entityId: companyId,
    createdBy: userId,
    modifiedBy: userId,
    entityName: entityName,
    itemStatus: constants.user.status.active,
    itemData: {
        userRole: constants.user.role.user
    }
};


const userInCompany = {
    companyId,
    itemId: constants.prefix.userPoolId + 'admin',
    userId: userId,
    itemData: {
        givenName: givenName + 'admin',
        familyName: familyName + 'admin',
        userEmail: userEmail + 'admin'
    }
};

const userInCompany2 = {
    companyId,
    itemId: constants.prefix.userPoolId + userName2,
    userId: userId2,
    itemData: {
        hidden: true,
        givenName: givenName + 'hidden',
        familyName: familyName + 'hidden',
        userEmail: userEmail + 'hidden'
    }
};

const userNotAdminInCompany = {
    companyId,
    itemId: constants.prefix.userPoolId + userName,
    userId: userIdAdminEntity,
    itemData: {
        givenName: givenName,
        familyName: familyName,
        userEmail: userEmail
    }
};



const userEvent = {
    requestContext: {
        identity: {
            cognitoIdentityId: userId
        }
    },
    queryStringParameters: {
        entityId: entityId
    }
}

const userEventForCompany = {
    requestContext: {
        identity: {
            cognitoIdentityId: userId
        }
    },
    queryStringParameters: {
        companyId
    }
}

const userEventEntityAdmin = {
    requestContext: {
        identity: {
            cognitoIdentityId: userIdAdminEntity
        }
    },
    queryStringParameters: {
        entityId: entityId
    }
}

const userEventEntityAdminCompany = {
    requestContext: {
        identity: {
            cognitoIdentityId: userIdAdminEntity
        }
    },
    queryStringParameters: {
        companyId
    }
}

const userEventAuthorised = {
    requestContext: {
        identity: {
            cognitoIdentityId: 'notAuthorised'
        }
    },
    queryStringParameters: {
        entityId: entityId
    }
}

const userEventMissingEntityId = {
    requestContext: {
        identity: {
            cognitoIdentityId: userId
        }
    }
}

describe('getUsers', () => {
    beforeAll(async () => {
        let response = await usersService.create(userItem);
        expect(response.userId).toBe(userId);
        response = await usersService.create(userItemAdminCompany);
        expect(response.userId).toBe(userId);
        response = await usersService.create(userItemAdminCompany2);
        expect(response.userId).toBe(userId2);
        response = await usersService.create(userItemAdminEntity);
        expect(response.userId).toBe(userIdAdminEntity);
        response = await usersService.create(userItemNotAdminCompany);
        expect(response.userId).toBe(userIdAdminEntity);
        response = await companiesService.create(userInCompany);
        expect(response.userId).toBe(userId);
        response = await companiesService.create(userInCompany2);
        expect(response.userId).toBe(userId2);
        response = await companiesService.create(userNotAdminInCompany);
        expect(response.userId).toBe(userIdAdminEntity);
    });

    it('get users for entity - entity admin, expect 200, and test data', async () => {
        let response = await wrapperGetUsers.run(userEventEntityAdmin)
        expect(response.statusCode).toBe(200);
        const body = JSON.parse(response.body);
        expect(body.length).toBe(2);
        expect(body).toMatchObject([{
            companyId: companyId,
            entityId: entityId,
            userId: userId,
            itemData: {
                role: constants.user.role.user,
                isEditor: true,
                userEmail: userEmail + 'admin',
                givenName: givenName + 'admin',
                familyName: familyName + 'admin',
                isCompanyAdmin: false,
            }
        },
        {
            companyId: companyId,
            entityId: entityId,
            userId: userIdAdminEntity,
            itemData: {
                role: constants.user.role.admin,
                isEditor: true,
                userEmail: userEmail,
                givenName: givenName,
                familyName: familyName,
                isCompanyAdmin: false,
            }
        }
        ]);
    });

    it('get users for company - compnay admin, expect 200, and test data', async () => {
        let response = await wrapperGetUsers.run(userEventForCompany)
        expect(response.statusCode).toBe(200);
        const body = JSON.parse(response.body);
        expect(body.length).toBe(4);
        expect(body).toMatchObject([
            {
                companyId: companyId,
                entityId: companyId,
                userId: userIdAdminEntity,
                itemData: {
                    role: constants.user.role.user,
                    isEditor: true,
                    userEmail: userEmail,
                    givenName: givenName,
                    familyName: familyName,
                    isCompanyAdmin: false,
                }
            },
            {
                companyId: companyId,
                entityId,
                userId: userId,
                itemData: {
                    role: constants.user.role.user,
                    isEditor: true,
                    userEmail: userEmail + 'admin',
                    givenName: givenName + 'admin',
                    familyName: familyName + 'admin',
                    isCompanyAdmin: true,
                }
            },
            {
                companyId: companyId,
                entityId: companyId,
                userId: userId,
                itemData: {
                    role: constants.user.role.admin,
                    isEditor: true,
                    userEmail: userEmail + 'admin',
                    givenName: givenName + 'admin',
                    familyName: familyName + 'admin',
                    isCompanyAdmin: true,
                }
            },{
                companyId: companyId,
                entityId: entityId,
                userId: userIdAdminEntity,
                itemData: {
                    role: constants.user.role.admin,
                    isEditor: true,
                    userEmail: userEmail,
                    givenName: givenName,
                    familyName: familyName,
                    isCompanyAdmin: false,
                }
            }
        ]);
    });

    it('get users for entity not admin test data', async () => {
        let response = await wrapperGetUsers.run(userEvent)
        expect(response.statusCode).toBe(200);
        const body = JSON.parse(response.body);
        expect(body.length).toBe(2);
    });

    it('get users for company not admin, expect 200, and test data', async () => {
        let response = await wrapperGetUsers.run(userEventEntityAdminCompany)
        expect(response.statusCode).toBe(200);
        const body = JSON.parse(response.body);
        expect(body.length).toBe(4);
    });

    it('get users, expect 500', async () => {
        let response = await wrapperGetUsers.run(userEventMissingEntityId)
        expect(response.statusCode).toBe(500);
    });

    it('get users, expect 403', async () => {
        let response = await wrapperGetUsers.run(userEventAuthorised)
        expect(response.statusCode).toBe(403);
    });

    // afterAll(async () => {
    //     //cleanup
    //     let result = await usersService.delete(userId, entityId);
    //     expect(result).toBe(true);
    //     result = await usersService.delete(userId, companyId);
    //     expect(result).toBe(true);
    //     result = await usersService.delete(userId2, companyId);
    //     expect(result).toBe(true);
    //     result = await usersService.delete(userIdAdminEntity, entityId);
    //     expect(result).toBe(true);
    //     result = await usersService.delete(userIdAdminEntity, companyId);
    //     expect(result).toBe(true);
    //     result = await companiesService.delete(userName);
    //     expect(result).toBe(true);
    //     result = await companiesService.delete(userName);
    //     expect(result).toBe(true);
    //     result = await companiesService.delete(userName + 'admin');
    //     expect(result).toBe(true);
    // });
});

