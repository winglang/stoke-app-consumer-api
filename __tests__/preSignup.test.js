'use strict';

// tests for cognitoPreSignup
// Generated by serverless-jest-plugin

const auth = require('../src/auth');
const jestPlugin = require('serverless-jest-plugin');
const lambdaWrapper = jestPlugin.lambdaWrapper;
const wrappedPreSignUp = lambdaWrapper.wrap(auth, { handler: 'preSignUp' });
const preSignUpEvent = require('../mocks/cognitoPreSignup-event.json');
const { CompaniesService, constants, jsonLogger } = require('stoke-app-common-api');
const companiesService = new CompaniesService(process.env.customersTableName, constants.projectionExpression.defaultAttributes, constants.attributeNames.defaultAttributes);
const { buildExternalProviderUserPoolId } = require('../src/helpers/userHelper')
const AWS = require('aws-sdk');
const cognitoidentityserviceprovider = new AWS.CognitoIdentityServiceProvider();

const jsonLoggerSpy = jest.spyOn(jsonLogger, 'info');

describe('cognitoPreSignup', () => {
  beforeAll((done) => {
    expect(process.env.PARAM_NAME_INVITATIONID_PASS).toBeTruthy(); 
    expect(process.env.PARAM_NAME_INVITATIONID_SALT).toBeTruthy(); 
    done();
  });

  it('cognitoPreSignup succesful operation', () => {
    return wrappedPreSignUp.run(preSignUpEvent).then((response) => {
      expect(response).toBeDefined();
    });
  });

  it('cognitoPreSignup wrong id, expect error', async () => {
    try{
      const wrongInvitationId = preSignUpEvent;
      wrongInvitationId.request.validationData= '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
      const response = await wrappedPreSignUp.run(wrongInvitationId);
    } catch (e) {
      expect(e.message).toMatch('Invalid Invitation ID');
    }
  });

  it('cognitoPreSignup missing id, expect error', async () => {
    try{
      const wrongInvitationId = preSignUpEvent;
      wrongInvitationId.request.validationData = null;
      const response = await wrappedPreSignUp.run(wrongInvitationId);
    } catch (e) {
      expect(e.message).toMatch('Invalid Invitation ID');
    }
  });

  describe('validations skipping', () => {
		describe('source PreSignUp_AdminCreateUser', () => {
			it('should skip validation', async () => {
				preSignUpEvent.triggerSource = constants.cognitoUserPoolLambdaTriggerSources.preSignUpAdminCreateUser
				
				wrappedPreSignUp.run(preSignUpEvent).then((response) => {
					expect(response).toBeDefined();
					expect(jsonLoggerSpy).toHaveBeenCalledWith({
					type: "TRACKING", 
					function: "users::preSignUp",
					text: 'skipping validation due to trigger source: PreSignUp_AdminCreateUser'
					})
				});
			})
		})

		describe('source PreSignUp_ExternalProvider', () => {
			const devUserPoolId = 'us-east-1_j0IcMHZI1'
			beforeEach(async () => {
				await companiesService.create({
					companyId: '111',
					itemId: buildExternalProviderUserPoolId(`first@${constants.knownSSODomains[0]}`),
					userId: '111',
					itemStatus: constants.user.status.invited,
					itemData: {
						userEmail: 'test1@test.com'
					}
				})
			})

			it('should skip validation when external item exists', async () => {
				preSignUpEvent.triggerSource = constants.cognitoUserPoolLambdaTriggerSources.preSignUpExternalProvider
				preSignUpEvent.userName = `Azure_first@${constants.knownSSODomains[0]}`
				preSignUpEvent.userPoolId = devUserPoolId
				
				wrappedPreSignUp.run(preSignUpEvent).then((response) => {
					expect(response).toBeDefined();
					expect(jsonLoggerSpy).toHaveBeenCalledWith({
						type: "TRACKING", 
						function: "users::preSignUp",
						text: 'skipping validation due to trigger source: PreSignUp_ExternalProvider',
						username: preSignUpEvent.userName
					})
				});
			})

			describe('PreSignUp_ExternalProvider - when external user already registered as native', () => {
				const userEmail = 'first@activefens.com'
				const eventUserName = `Okta_${userEmail}`
				const newUserParams = { UserPoolId: devUserPoolId, Username: userEmail }
				
				beforeAll(async (done) => {
					await companiesService.create({
						companyId: '111',
						itemId: buildExternalProviderUserPoolId(userEmail),
						userId: '222',
						itemStatus: constants.user.status.invited,
						itemData: {
							userEmail
						}
					})
					
					try {
						await cognitoidentityserviceprovider.adminDeleteUser(newUserParams).promise()
					} catch(error) {
						console.log("failed cleaning user. continue")
					}

					try {
						await cognitoidentityserviceprovider.deleteIdentityProvider({ UserPoolId: devUserPoolId, ProviderName: 'Okta' }).promise()
					} catch (error) {
						console.log("failed cleaning identity. continue")
					}
					
					try {
						await cognitoidentityserviceprovider.adminCreateUser(newUserParams).promise()
						await cognitoidentityserviceprovider.createIdentityProvider({ 
							ProviderName: "Okta",
							UserPoolId: devUserPoolId,
							ProviderType: 'SAML',
							ProviderDetails: { MetadataURL: 'https://login.microsoftonline.com/85194a1d-a974-4f77-8c8d-64011f31b14f/federationmetadata/2007-06/federationmetadata.xml?appid=dde1e1a8-1243-4c14-8e64-2e7a0e93a7b4'} 
						}).promise()
							
					} catch (error) {
						console.log("failed adminCreateUser. continue", error)
					}
					
					done()
				})

				it('should link the source account with the provider one', async () => {
					preSignUpEvent.triggerSource = constants.cognitoUserPoolLambdaTriggerSources.preSignUpExternalProvider
					preSignUpEvent.request.userAttributes.email = userEmail
					preSignUpEvent.userPoolId = devUserPoolId
					preSignUpEvent.userName = eventUserName
					
					const response = await wrappedPreSignUp.run(preSignUpEvent)
					expect(response).toBeDefined();
					
					const cognitoUser = await cognitoidentityserviceprovider.adminGetUser({ UserPoolId: devUserPoolId, Username: userEmail }).promise()
					const userAttributes = cognitoUser.UserAttributes
					const identities = userAttributes.find((attribute) => attribute['Name'] === 'identities')
					expect(identities).toBeDefined();
				})
			})
		})
	})
});

