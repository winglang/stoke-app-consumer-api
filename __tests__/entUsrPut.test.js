/* eslint-disable no-undef */
'use strict';

// tests for users.js functions
// Generated by serverless-jest-plugin

const mod = require('../src/users');
const jestPlugin = require('serverless-jest-plugin');
const { UsersService, constants } = require('stoke-app-common-api');
const usersService = new UsersService(process.env.consumerAuthTableName, constants.projectionExpression.defaultAttributes, constants.attributeNames.defaultAttributes);
const lambdaWrapper = jestPlugin.lambdaWrapper;
const wrapperUpdateUser = lambdaWrapper.wrap(mod, { handler: 'updateUserInEntity' });

const userId = "JEST-TEST-UPDATE-USERS"
const userIdAdmin = "JEST-TEST-UPDATE-USERS-ADMIN"

const entityId = "JEST-TEST-UPDATE-USERS-ENTITY"
const userName = "joe@stokeco.com"
const userEmail = "joe@stokeco.com"
const userEmailAdmin = "joeAdmin@stokeco.com"
const newUserEmail = "newJoe@stokeco.com"
const givenName = "joe"
const newGivenName = "newJoe"
const familyName = "newShmoe"
const newFamilyName = "Shmoe"
const entityName = "stoke"
const companyId = "JEST-TEST-UPDATE-USERS-ADMIN-COMPANY-ID"

const userItemAdmin = {
    userId: userIdAdmin,
    companyId: companyId,
    userName: userName,
    userEmail: userEmailAdmin,
    givenName: givenName,
    familyName: familyName,
    entityId: entityId,
    createdBy: userIdAdmin,
    modifiedBy: userIdAdmin,
    entityName: entityName,
    itemData: {
        userRole: constants.user.role.admin, isEditor: true
    },
    itemStatus: constants.user.status.active
};

const userItem = {
    userId: userId,
    userName: userName,
    companyId: companyId,
    userEmail: userEmail,
    givenName: givenName,
    familyName: familyName,
    entityId: entityId,
    createdBy: userId,
    modifiedBy: userId,
    entityName: entityName,
    itemStatus: constants.user.status.active,
    itemData: {
        userRole: constants.user.role.user, isEditor: true
    }
};

const updateUserEvent = {
    pathParameters: {
        id: userId
    },
    body: JSON.stringify({
        userEmail: newUserEmail,
        givenName: newGivenName,
        familyName: newFamilyName,
        userRole: 'fake',
        entityId: entityId,
        itemStatus: constants.user.status.invited,
    }),
    requestContext: {
        identity: {
            cognitoIdentityId: userIdAdmin
        }
    }
}

const updateUserEventWithNowditorAttr = {
    pathParameters: {
        id: userId
    },
    body: JSON.stringify({
        userEmail: newUserEmail,
        givenName: newGivenName,
        familyName: newFamilyName,
        userRole: 'fake',
        isEditor: false,
        entityId: entityId,
        itemStatus: constants.user.status.invited,
    }),
    requestContext: {
        identity: {
            cognitoIdentityId: userIdAdmin
        }
    }
}

const updateAdminUserEvent = {
    pathParameters: {
        id: userEmailAdmin
    },
    body: JSON.stringify({
        userEmail: newUserEmail,
        givenName: newGivenName,
        familyName: newFamilyName,
        userRole: 'fake',
        entityId: entityId
    }),
    requestContext: {
        identity: {
            cognitoIdentityId: userId
        }
    }
}

const updateAdditionalRolesNotEditor = {
    pathParameters: {
        id: userId
    },
    body: JSON.stringify({
        entityId,
        isBudgetOwner: true,
        isJobsApprover: true,
    }),
    requestContext: {
        identity: {
            cognitoIdentityId: userIdAdmin
        }
    }
};

const updateUserEventWithAdditionalRoles = {
    pathParameters: {
        id: userId
    },
    body: JSON.stringify({
        isEditor: true,
        entityId: entityId,
        isBudgetOwner: true,
        isJobsApprover: true,
        userRole: constants.user.role.admin,
    }),
    requestContext: {
        identity: {
            cognitoIdentityId: userIdAdmin
        }
    }
};

const updateAdditionalRolesFailure = {
    pathParameters: {
        id: userId
    },
    body: JSON.stringify({
        entityId,
        isBudgetOwner: true,
        isJobsApprover: true,
        isEditor: false,
    }),
    requestContext: {
        identity: {
            cognitoIdentityId: userIdAdmin
        }
    }
};


// eslint-disable-next-line max-lines-per-function
describe('updateUser', () => {
    beforeAll(async () => {
        let response = await usersService.create(userItemAdmin);
        expect(response.userId).toBe(userIdAdmin);
        response = await usersService.create(userItem);
        expect(response.userId).toBe(userId);
    });

    it('update user, expect 200, and test data', async () => {
        let response = await wrapperUpdateUser.run(updateUserEvent)
        expect(response.statusCode).toBe(200);
        let body = JSON.parse(response.body);
        expect(body.Attributes).toMatchObject({
            itemStatus: constants.user.status.invited,
            itemData: {
                userRole: 'fake', isEditor: true
            }
        });
        response = await wrapperUpdateUser.run(updateUserEventWithNowditorAttr)
        expect(response.statusCode).toBe(200);
        body = JSON.parse(response.body);
        expect(body.Attributes).toMatchObject({
            itemStatus: constants.user.status.invited,
            itemData: {
                userRole: 'fake', isEditor: false
            }
        });
        await usersService.update({
            userId: userItemAdmin.userId, entityId: userItemAdmin.entityId, modifiedBy: userItemAdmin.userId, itemData: {
                userRole: constants.user.role.admin,
                isEditor: false
            }
        })
        response = await wrapperUpdateUser.run(updateUserEvent)
        expect(response.statusCode).toBe(403);
        await usersService.update({
            userId: userItemAdmin.userId, entityId: userItemAdmin.entityId, modifiedBy: userItemAdmin.userId, itemData: {
                userRole: constants.user.role.admin,
                isEditor: true
            }
        })

    });

    it('update user, expect 403', async () => {
        let response = await wrapperUpdateUser.run(updateAdminUserEvent)
        expect(response.statusCode).toBe(403);
    });

    it('update additional roles, return failure when user is not editor', async () => {
        await usersService.update({
            userId,
            entityId: userItem.entityId,
            modifiedBy: 'test',
            itemData: {
                userRole: constants.user.role.admin,
                isEditor: false
            }
        })
        const response = await wrapperUpdateUser.run(updateAdditionalRolesNotEditor);
        expect(response.statusCode).toBe(500);
    });

    it('update user additional roles', async () => {
        const response = await wrapperUpdateUser.run(updateUserEventWithAdditionalRoles);
        expect(response.statusCode).toBe(200);
        const body = JSON.parse(response.body);
        expect(body.Attributes.itemData).toMatchObject({
            isEditor: true,
            isJobsApprover: true,
            isBudgetOwner: true,
        });
    });

    it('update additional roles, return failure', async () => {
        const response = await wrapperUpdateUser.run(updateAdditionalRolesFailure);
        expect(response.statusCode).toBe(500);
    });

    afterAll(async () => {
        //cleanup
        let result = await usersService.delete(userIdAdmin, entityId);
        expect(result).toBe(true);
        result = await usersService.delete(userId, entityId);
        expect(result).toBe(true);
    });
});

