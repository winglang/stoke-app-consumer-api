'use strict';

// tests for users.js functions
// Generated by serverless-jest-plugin

const mod = require('../src/companies');
const jestPlugin = require('serverless-jest-plugin');
const lambdaWrapper = jestPlugin.lambdaWrapper;
const deleteUserInCompany = lambdaWrapper.wrap(mod, { handler: 'deleteUserInCompany' });

const CompanyCreator = require('./mock/companyCreator');
const creator = new CompanyCreator('CompUsrRem');
const {
    companyId, entityId1, entityId2, entityId4,
    userId1, userId2, userId3, userId4, userId6, adminUserId, ssoUserId,
    userPoolUserId1, userPoolUserId2, userPoolUserId3, userPoolUserId4, userPoolUserId6, userPoolInvitedUserId, userPoolSsoUserId,
} = creator;

const { constants, UsersService, CompaniesService } = require("stoke-app-common-api");
const usersService = new UsersService(process.env.consumerAuthTableName, constants.projectionExpression.defaultAttributes, constants.attributeNames.defaultAttributes);
const companiesService = new CompaniesService(process.env.customersTableName, constants.projectionExpression.defaultAttributes, constants.attributeNames.defaultAttributes);

const event = (userPoolUserIdToDelete, userId, isValidation, isUndo, undoCompanyId) => ({
    requestContext: {
        identity: {
            cognitoIdentityId: userId
        }
    },
    pathParameters: {
        id: userPoolUserIdToDelete
    },
    queryStringParameters: { isValidation: isValidation?.toString(), isUndo: isUndo?.toString(), undoCompanyId },
});

describe('deleteUsersInCompany', () => {
    beforeEach(async () => {
        await creator.create();
    });

    afterEach(async () => {
        await creator.delete();
    });

    it("delete user - and reactivate basic flow", async () => {
        const response = await deleteUserInCompany.run(event(userPoolUserId1, adminUserId));
        expect(response.statusCode).toBe(200);

        const entityUserAfterUpdate = await usersService.get(userId1, entityId1);
        expect(entityUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.inactive,
        });
        const companyUserAfterUpdate = await companiesService.get(userPoolUserId1);
        expect(companyUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.inactive,
        });
        
        // Reactivate user
        const response2 = await deleteUserInCompany.run(event(userId1, adminUserId, false, true, companyId));
        expect(response2.statusCode).toBe(200);

        const entityUserAfterUpdate2 = await usersService.get(userId1, entityId1);
        expect(entityUserAfterUpdate2).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
        const companyUserAfterUpdate2 = await companiesService.get(userPoolUserId1);
        expect(companyUserAfterUpdate2).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
                
    });

    it("delete user - and reactivate basic flow - sso user registration", async () => {
        const response = await deleteUserInCompany.run(event(userPoolSsoUserId, adminUserId));
        expect(response.statusCode).toBe(200);

        const entityUserAfterUpdate = await usersService.get(ssoUserId, entityId1);
        expect(entityUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.inactive,
        });
        const companyUserAfterUpdate = await companiesService.get(userPoolSsoUserId);

        expect(companyUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.inactive,
        });
        
        // Reactivate user
        const response2 = await deleteUserInCompany.run(event(ssoUserId, adminUserId, false, true, companyId));
        expect(response2.statusCode).toBe(200);

        const entityUserAfterUpdate2 = await usersService.get(ssoUserId, entityId1);
        expect(entityUserAfterUpdate2).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
        const companyUserAfterUpdate2 = await companiesService.get(userPoolSsoUserId);
        expect(companyUserAfterUpdate2).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
    })

    it("delete user - unauthorized", async () => {
        const response = await deleteUserInCompany.run(event(userPoolUserId1, userId2));
        expect(response.statusCode).toBe(403);

        const entityUserAfterUpdate = await usersService.get(userId1, entityId1);
        expect(entityUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
        const companyUserAfterUpdate = await companiesService.get(userPoolUserId1);
        expect(companyUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
    });

    it("delete user - error user has active jobs", async () => {
        const response = await deleteUserInCompany.run(event(userPoolUserId2, adminUserId));
        expect(response.statusCode).toBe(200);

        const data = JSON.parse(response.body);
        expect(data.status).toBe(false);
        const userAfterUpdate = await usersService.get(userId2, entityId1);
        expect(userAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
    });

    it("delete user - budget basic flow - only past budgets", async () => {
        const response = await deleteUserInCompany.run(event(userPoolUserId3, adminUserId));
        expect(response.statusCode).toBe(200);

        const userAfterUpdate = await usersService.get(userId3, entityId2);
        expect(userAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.inactive,
        });
        const companyUserAfterUpdate = await companiesService.get(userPoolUserId3);
        expect(companyUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.inactive,
        });
    });

    it("delete user - budget basic flow - has future budgets - should return validation error", async () => {
        const response = await deleteUserInCompany.run(event(userPoolUserId4, adminUserId));
        expect(response.statusCode).toBe(200);
        const data = JSON.parse(response.body);
        
        const userAfterUpdate = await usersService.get(userId4, entityId2);
        expect(userAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
        expect(data.reason).toBe("USER_HAS_FUTURE_BUDGETS")
    });

    it("delete user - budget basic flow - has no future budget, but company pool - should return validation error", async () => {
        const response = await deleteUserInCompany.run(event(userPoolUserId6, adminUserId));
        expect(response.statusCode).toBe(200);
        const userAfterUpdate = await usersService.get(userId6, entityId4);
        expect(userAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.active,
        });
        const data = JSON.parse(response.body);
        expect(data.reason).toBe("USER_HAS_COMPANY_POOL")
    });

    it("delete user - invited user didn't register yet", async () => {
        const response = await deleteUserInCompany.run(event(userPoolInvitedUserId, adminUserId));
        expect(response.statusCode).toBe(200);
        const companyUserAfterUpdate = await companiesService.get(userPoolInvitedUserId);
        expect(companyUserAfterUpdate).toMatchObject({
            itemStatus: constants.itemStatus.inactive,
        });
    });

});
